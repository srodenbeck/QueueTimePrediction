import pandas as pdimport matplotlib.pyplot as pltimport numpy as npimport sqlalchemyimport seaborn as snsimport config_filedef create_engine():    db_config = {        "dbname": "sacctdata",        "user": "postgres",        "password": config_file.postgres_password,        "host": "slurm-data-loadbalancer.reu-p4.anvilcloud.rcac.purdue.edu",        "port": "5432"    }        engine = sqlalchemy.create_engine(        f'postgresql+psycopg2://{db_config["user"]}:{db_config["password"]}@{db_config["host"]}:{db_config["port"]}/{db_config["dbname"]}')    return enginedef plot_best_fit(ax, x, y):    coeffs = np.polyfit(x, y, 1)    poly = np.poly1d(coeffs)    y_fit = poly(x)    ax.plot(x, y_fit, color='red', linestyle='--', label='Best Fit Line')    ax.legend()if __name__ == "__main__":    engine = create_engine()    df = pd.read_sql_query("""SELECT job_id, eligible, req_cpus, req_mem, req_nodes,                           priority, jobs_ahead_queue, cpus_ahead_queue, memory_ahead_queue,                           nodes_ahead_queue, time_limit_ahead_queue, jobs_running,                           memory_running, nodes_running, time_limit_running,                           planned FROM new_jobs_all ORDER BY eligible""", engine)        print(df['jobs_ahead_queue'])    print()    print(max(df['jobs_ahead_queue']))    print(sum(df['jobs_ahead_queue']) / len(df['jobs_ahead_queue']))    print()        ranges = [        (0, 10 * 60),        (10 * 60, 60 * 60),        (60 * 60, 4 * 60 * 60),        (4 * 60 * 60, 24 * 60 * 60),        (24 * 60 * 60, float('inf'))    ]        # Create a dictionary to store the smaller dataframes    dataframes = {}        # Loop through the ranges and filter the dataframe    for i, (start, end) in enumerate(ranges):        dataframes[f'df_{i}'] = df[(df['planned'] > start) & (df['planned'] <= end)]        combined_df = pd.DataFrame()    for key, dataframe in dataframes.items():        range_label = key  # Use the key as the label        dataframe['range'] = range_label        combined_df = pd.concat([combined_df, dataframe])        # List of columns to plot    columns_to_plot = ['req_cpus', 'req_mem', 'req_nodes', 'priority', 'jobs_ahead_queue',                        'cpus_ahead_queue', 'memory_ahead_queue', 'nodes_ahead_queue',                        'time_limit_ahead_queue', 'jobs_running', 'memory_running',                        'nodes_running', 'time_limit_running']        # Set up the plotting environment    plt.figure(figsize=(15, 10))        # Loop through each column and create a boxplot    # Note: 0 < df_0 < 10 minutes, 10 minutes < df_1 < 60 minutes,    # 1 hour < df_2 < 4 hours, 4 hours < df_3 < 24 hours, 24 hours < df_4    for column in columns_to_plot:        plt.figure()        sns.boxplot(x='range', y=column, data=combined_df, showfliers=False)        plt.title(f'Boxplot of {column} across different planned ranges')        plt.xlabel('Planned Range')        plt.ylabel(column)        plt.xticks(rotation=45)        plt.savefig(f"graphs/boxplots_by_time/{column}_boxplot.png")        plt.show()        # independent_vars = ['jobs_running', 'cpus_running', 'memory_running',    #                     'nodes_running', 'time_limit_running']    # y = df['planned'].values    # f, axs = plt.subplots(nrows=len(independent_vars), ncols=1, figsize=(10, 15))    # print("Starting plots")    # for i, name in enumerate(independent_vars):    #     print(f"Plotting {name} vs planned")    #     x = df[name].values    #     axs[i].scatter(x, y)    #     axs[i].set_title(f"{name} vs Planned Time (s)")    #     axs[i].set_xlabel(name)    #     axs[i].set_ylabel("Delay (s)")    #     plot_best_fit(axs[i], x, y)    # plt.tight_layout()    # plt.savefig("more_graphs.png")    # plt.show()    # print("Finished plots")                                